<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Pro Client - Multi-User</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#6366f1',
                        'primary-dark': '#4f46e5',
                        secondary: '#8b5cf6',
                    }
                }
            }
        }
    </script>
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        .spinner { animation: spin 1s linear infinite; }
        .toast { animation: slideIn 0.3s ease; }
        .progress-shimmer::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 1.5s infinite;
        }
        #editor {
            height: 100%;
            min-height: 500px;
        }
        /* Style for modified file indicator */
        .file-modified-indicator {
            color: #eab308; /* yellow-500 */
            font-weight: bold;
            margin-left: 8px;
            font-size: 0.75rem;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-500 via-purple-500 to-pink-500">
    <div class="flex h-screen overflow-hidden">
        <div class="w-72 bg-gray-900 text-white flex flex-col shadow-2xl">
            <div class="p-6 bg-gray-800 border-b border-gray-700">
                <div class="flex items-center gap-3">
                    <i class="fab fa-github text-3xl text-indigo-400"></i>
                    <span class="text-xl font-bold">GitHub Pro</span>
                </div>
                <div class="mt-3" id="permissionBadge"></div>
                <div class="mt-2" id="authStatus"></div>
            </div>
            
            <nav class="flex-1 overflow-y-auto py-4">
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500 active" onclick="switchView('repo')">
                    <i class="fas fa-database w-5"></i>
                    <span>Repository</span>
                </div>
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500" onclick="switchView('files')">
                    <i class="fas fa-folder w-5"></i>
                    <span>File Explorer</span>
                </div>
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500" onclick="switchView('source-control')">
                    <i class="fas fa-code-branch w-5"></i>
                    <span>Source Control</span>
                </div>
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500" onclick="switchView('search')">
                    <i class="fas fa-search w-5"></i>
                    <span>Search Code</span>
                </div>
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500" onclick="switchView('commits')">
                    <i class="fas fa-code-commit w-5"></i>
                    <span>Commits</span>
                </div>
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500" onclick="switchView('branches')">
                    <i class="fas fa-code-branch w-5"></i>
                    <span>Branches</span>
                </div>
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500" onclick="switchView('info')">
                    <i class="fas fa-info-circle w-5"></i>
                    <span>Repository Info</span>
                </div>
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500" onclick="switchView('permissions')">
                    <i class="fas fa-user-shield w-5"></i>
                    <span>Permissions</span>
                </div>
                <div class="nav-item flex items-center gap-3 px-6 py-3 cursor-pointer hover:bg-gray-800 transition-colors border-l-4 border-transparent hover:border-indigo-500" onclick="switchView('settings')">
                    <i class="fas fa-cog w-5"></i>
                    <span>Settings</span>
                </div>
            </nav>
        </div>

        <div class="flex-1 flex flex-col bg-gray-50 overflow-hidden">
            <div class="bg-white shadow-md px-6 py-4 flex items-center justify-between">
                <div class="flex items-center gap-4">
                    <h1 class="text-xl font-semibold text-gray-800" id="topbarTitle">GitHub Pro Client</h1>
                    <span class="hidden bg-indigo-600 text-white px-3 py-1 rounded-full text-sm font-medium" id="repoBadge"></span>
                    <span class="hidden text-sm text-gray-600" id="userInfo"></span>
                </div>
                <div class="flex gap-3">
                    <button class="hidden bg-emerald-500 hover:bg-emerald-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2" onclick="downloadAsZip()" id="downloadZipBtn">
                        <i class="fas fa-download"></i> Download ZIP
                    </button>
                    <button class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2" onclick="clearAllData()">
                        <i class="fas fa-trash"></i> Clear All
                    </button>
                </div>
            </div>

            <div class="flex-1 overflow-y-auto overflow-x-hidden">
                <div class="view-container p-6" id="view-repo">
                    <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
                        <h2 class="text-xl font-semibold text-gray-800 mb-6 flex items-center gap-2">
                            <i class="fas fa-database text-indigo-600"></i>
                            Repository Management
                        </h2>
                        
                        <div class="mb-5">
                            <label class="block text-sm font-medium text-gray-700 mb-2">
                                <i class="fas fa-key"></i> GitHub Personal Access Token (Optional for public repos)
                            </label>
                            <div class="flex gap-2">
                                <input type="password" id="tokenInput" class="flex-1 px-4 py-3 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none transition-colors" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx (leave empty for public repos)">
                                <button class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-3 rounded-lg font-medium transition-colors" onclick="updateToken()">
                                    <i class="fas fa-sync"></i> Update
                                </button>
                            </div>
                            <p class="text-xs text-gray-500 mt-2">
                                Token needed for: private repos, pushing changes, higher API rate limits
                            </p>
                        </div>

                        <div class="grid grid-cols-2 gap-4 mb-5">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">
                                    <i class="fab fa-github"></i> Repository URL or Owner/Repo
                                </label>
                                <input type="text" id="repoInput" class="w-full px-4 py-3 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none transition-colors" placeholder="owner/repo">
                            </div>
                            <button class="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-3 rounded-lg font-medium transition-colors flex items-center gap-2 self-end" onclick="syncMetadata()">
                                <i class="fas fa-sync"></i> Sync Metadata
                            </button>
                        </div>
                        
                        <div id="repoMetadataSection" class="hidden">
                            <div class="bg-gray-50 rounded-lg p-4 mb-6" id="repoMetadataOutput">
                                </div>

                            <div class="grid grid-cols-2 gap-4 mb-5">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">
                                        <i class="fas fa-code-branch"></i> Select Branch
                                    </label>
                                    <select id="branchSelect" class="w-full px-4 py-3 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none transition-colors bg-white">
                                        <option value="main">main (default)</option>
                                    </select>
                                </div>
                                <button class="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-3 rounded-lg font-medium transition-colors flex items-center gap-2 self-end" onclick="cloneRepository()">
                                    <i class="fas fa-download"></i> Clone Full Repository
                                </button>
                            </div>
                            
                            <p class="text-sm text-gray-600 mb-4 text-center">--- OR ---</p>

                            <button class="bg-gray-600 hover:bg-gray-700 text-white px-6 py-3 rounded-lg font-medium transition-colors flex items-center gap-2" onclick="browseFilesOnly()">
                                <i class="fas fa-folder-open"></i> Browse Files (Download on-demand)
                            </button>
                        </div>


                        <div id="cloneProgress" class="hidden my-5">
                            <div class="w-full h-2 bg-gray-200 rounded-full overflow-hidden">
                                <div class="h-full bg-gradient-to-r from-indigo-500 to-purple-600 transition-all duration-300 relative progress-shimmer" id="cloneProgressBar" style="width: 0%"></div>
                            </div>
                            <p class="text-sm text-gray-600 mt-2" id="cloneProgressText">Preparing...</p>
                        </div>
                    </div>

                    <div class="hidden grid grid-cols-4 gap-4 mb-6" id="statsGrid">
                        </div>

                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <h3 class="text-lg font-semibold text-gray-800 mb-4">Console Output</h3>
                        <div class="bg-gray-900 text-green-400 p-5 rounded-lg font-mono text-sm h-96 overflow-y-auto" id="consoleOutput"></div>
                    </div>
                </div>

                <div class="view-container hidden p-6" id="view-files">
                    <div class="grid grid-cols-[300px_1fr] gap-6 h-[calc(100vh-140px)]">
                        <div class="bg-white rounded-xl shadow-lg p-4 overflow-y-auto">
                            <h3 class="text-lg font-semibold text-gray-800 mb-4">File Tree</h3>
                            <div id="fileTree" class="text-sm">
                                <div class="text-center text-gray-400 py-8">Clone a repository first</div>
                            </div>
                        </div>
                        <div class="bg-white rounded-xl shadow-lg flex flex-col overflow-hidden">
                            <div class="bg-gray-800 text-white px-6 py-4 flex items-center justify-between">
                                <div class="flex items-center gap-3 font-medium" id="editorFilename">
                                    <i class="fas fa-file-code"></i>
                                    <span>No file selected</span>
                                </div>
                                <div class="flex gap-3">
                                    <button class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2 disabled:opacity-50 disabled:cursor-not-allowed" onclick="saveFile()" id="saveBtn" disabled>
                                        <i class="fas fa-save"></i> Save Changes
                                    </button>
                                </div>
                            </div>
                            <div id="editor" class="flex-1"></div>
                        </div>
                    </div>
                </div>

                <div class="view-container hidden p-6" id="view-source-control">
                    <div class="grid grid-cols-[350px_1fr] gap-6">
                        <div class="bg-white rounded-xl shadow-lg p-6">
                            <h2 class="text-xl font-semibold text-gray-800 mb-6 flex items-center gap-2">
                                <i class="fas fa-code-branch text-indigo-600"></i>
                                Source Control
                            </h2>
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Commit Message</label>
                                <textarea id="commitMessage" class="w-full px-4 py-3 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none transition-colors resize-none" rows="4" placeholder="Describe your changes..."></textarea>
                            </div>
                            <button class="w-full bg-emerald-500 hover:bg-emerald-600 text-white px-6 py-3 rounded-lg font-medium transition-colors flex items-center justify-center gap-2" onclick="commitAndPushAll()">
                                <i class="fas fa-upload"></i> Commit & Push All Changes
                            </button>
                        </div>

                        <div class="bg-white rounded-xl shadow-lg p-6">
                             <h3 class="text-lg font-semibold text-gray-800 mb-4">Changes</h3>
                             <div id="changedFilesList" class="space-y-2">
                                <div class="text-center text-gray-400 py-8">No changes detected</div>
                             </div>
                        </div>
                    </div>
                </div>

                <div class="view-container hidden p-6" id="view-search">
                    </div>

                <div class="view-container hidden p-6" id="view-commits">
                    </div>

                <div class="view-container hidden p-6" id="view-branches">
                    <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
                        <h2 class="text-xl font-semibold text-gray-800 mb-6 flex items-center gap-2">
                            <i class="fas fa-plus text-indigo-600"></i>
                            Create New Branch
                        </h2>
                        <div class="grid grid-cols-[1fr_1fr_auto] gap-4">
                            <input type="text" id="newBranchName" class="w-full px-4 py-3 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none transition-colors" placeholder="new-branch-name">
                            <input type="text" id="newBranchSource" class="w-full px-4 py-3 border-2 border-gray-200 rounded-lg focus:border-indigo-500 focus:outline-none transition-colors" placeholder="Source branch (e.g., main)">
                            <button class="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-3 rounded-lg font-medium transition-colors flex items-center gap-2" onclick="createNewBranch()">
                                <i class="fas fa-plus"></i> Create
                            </button>
                        </div>
                    </div>
                    
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <div class="flex items-center justify-between mb-6">
                            <h2 class="text-xl font-semibold text-gray-800 flex items-center gap-2">
                                <i class="fas fa-code-branch text-indigo-600"></i>
                                Existing Branches
                            </h2>
                            <button class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-2" onclick="loadBranches()">
                                <i class="fas fa-sync"></i> Refresh
                            </button>
                        </div>
                        <div class="space-y-4" id="branchesList"></div>
                    </div>
                </div>

                <div class="view-container hidden p-6" id="view-info">
                    </div>
                
                <div class="view-container hidden p-6" id="view-permissions">
                    </div>

                <div class="view-container hidden p-6" id="view-settings">
                    </div>
            </div>
        </div>
    </div>

    <div class="hidden fixed inset-0 bg-black bg-opacity-70 items-center justify-center z-50" id="loadingOverlay">
        </div>

    <div class="fixed top-6 right-6 z-50 flex flex-col gap-3" id="toastContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        var originalDefine = window.define;
        window.define = undefined; // Hide AMD from FileSaver
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        window.define = originalDefine; // Restore AMD
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.js"></script>

    <script>
        // Global state
        let db;
        let currentRepo = {
            owner: '',
            repo: '',
            branch: '',
            token: ''
        };
        let userPermissions = {
            permission: 'none', // none, read, write, admin
            canPush: false,
            canPull: true,
            isOwner: false,
            username: '',
            authenticated: false
        };
        let monacoEditor;
        let monacoInitPromise = null;
        let currentFile = {
            path: null,
            originalContent: '' // Store original content to check for modifications
        };
        let fileModified = false; // Tracks if editor content has changed *since last load*

        // Service Worker Registration
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./service-worker.js')
                        .then(reg => {
                            console.log('Service Worker registered', reg);
                            log('üîß Service Worker ready');
                        })
                        .catch(err => {
                            console.error('Service Worker registration failed', err);
                            log('‚ùå Service Worker registration failed', 'text-red-400');
                        });
                });
            } else {
                log('‚ö†Ô∏è Service Workers not supported in this browser', 'text-yellow-400');
            }

            // TODO: Add 'message' listener to receive updates from SW (e.g., for multi-tab sync)
            // navigator.serviceWorker.onmessage = (event) => {
            //     console.log('Message from SW:', event.data);
            //     if (event.data.type === 'STATE_UPDATE') {
            //         // e.g., reload file tree
            //         loadFileTree();
            //     }
            // };
        }
        
        // SW-REFACTOR: Send message to Service Worker
        function postToSW(message) {
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage(message);
            } else {
                showToast('Service Worker not ready. Please reload.', 'error');
            }
        }

        // SW-REFACTOR: All DB logic should move to the Service Worker.
        // For now, we keep it here for simplicity.
        function initDB() {
            return new Promise((resolve, reject) => {
                // TODO: DB name should be generic, not repo-specific
                const request = indexedDB.open('GitHubProDB', 2); // Version 2 for new schema
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    if (!db.objectStoreNames.contains('files')) {
                        // TODO: Key should be [repoFullName, branch, path]
                        const fileStore = db.createObjectStore('files', { keyPath: 'path' });
                        // Add index for 'isDirty' to quickly find changes
                        fileStore.createIndex('isDirty', 'isDirty', { unique: false });
                    }
                    if (!db.objectStoreNames.contains('metadata')) {
                         // TODO: Key should be [repoFullName, key]
                        db.createObjectStore('metadata', { keyPath: 'key' });
                    }
                };
            });
        }

        // DB operations (would be replaced by postToSW)
        async function saveToIndexedDB(storeName, data) {
            return new Promise((resolve, reject) => {
                // TODO: Add repo/branch scoping
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        async function getFromIndexedDB(storeName, key) {
            return new Promise((resolve, reject) => {
                // TODO: Add repo/branch scoping
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        async function getAllFromIndexedDB(storeName) {
            return new Promise((resolve, reject) => {
                // TODO: Add repo/branch scoping
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
        async function clearIndexedDB(storeName) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        // NEW: Get all 'dirty' (modified) files
        async function getDirtyFiles() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['files'], 'readonly');
                const store = transaction.objectStore('files');
                const index = store.index('isDirty');
                const request = index.getAll(true); // Get all where isDirty = true
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }


        // ... hasToken, getHeaders, checkUserPermissions, updatePermissionUI ...
        // (These functions are mostly unchanged)
        function hasToken() {
            return currentRepo.token && currentRepo.token.trim() !== '';
        }

        // Update token
        async function updateToken() {
            const newToken = document.getElementById('tokenInput').value.trim();
            currentRepo.token = newToken;
            
            if (currentRepo.owner && currentRepo.repo) {
                await saveToIndexedDB('metadata', {
                    key: 'currentRepo',
                    value: currentRepo
                });
                
                if (hasToken()) {
                    showLoading('Checking permissions...', 'Please wait');
                    await checkUserPermissions();
                    hideLoading();
                    showToast('Token updated and permissions refreshed', 'success');
                } else {
                    userPermissions.authenticated = false;
                    userPermissions.canPush = false;
                    userPermissions.permission = 'read';
                    userPermissions.username = 'Anonymous';
                    updatePermissionUI();
                    showToast('Token removed - using public access mode', 'info');
                }
            } else {
                showToast('Token saved - will be used for next sync', 'info');
            }
        }

        // GitHub API Helper - with optional auth
        function getHeaders() {
            const headers = {
                'Accept': 'application/vnd.github+json',
                'X-GitHub-Api-Version': '2022-11-28'
            };
            
            if (hasToken()) {
                headers['Authorization'] = `Bearer ${currentRepo.token}`;
            }
            
            return headers;
        }

        // Permission Management
        async function checkUserPermissions() {
            try {
                if (!hasToken()) {
                    // No token - public access mode
                    userPermissions.authenticated = false;
                    userPermissions.permission = 'read';
                    userPermissions.canPush = false;
                    userPermissions.canPull = true;
                    userPermissions.isOwner = false;
                    userPermissions.username = 'Anonymous (Public Access)';
                    updatePermissionUI();
                    log(`‚úì Mode: Public access (no authentication)`);
                    return;
                }

                // Get authenticated user info
                const userResponse = await fetch('https://api.github.com/user', {
                    headers: getHeaders()
                });

                if (!userResponse.ok) {
                    throw new Error('Invalid token or authentication failed');
                }

                const user = await userResponse.json();
                userPermissions.username = user.login;
                userPermissions.authenticated = true;

                // Get repository permissions
                const permResponse = await fetch(
                    `https://api.github.com/repos/${currentRepo.owner}/${currentRepo.repo}`,
                    { headers: getHeaders() }
                );

                if (!permResponse.ok) {
                    userPermissions.permission = 'none';
                    userPermissions.canPush = false;
                    userPermissions.canPull = false;
                    updatePermissionUI();
                    return;
                }

                const repoData = await permResponse.json();
                
                // Check if user is owner
                userPermissions.isOwner = repoData.owner.login === user.login;

                // Determine permissions
                if (userPermissions.isOwner || repoData.permissions?.admin) {
                    userPermissions.permission = 'admin';
                    userPermissions.canPush = true;
                    userPermissions.canPull = true;
                } else if (repoData.permissions?.push) {
                    userPermissions.permission = 'write';
                    userPermissions.canPush = true;
                    userPermissions.canPull = true;
                } else if (repoData.permissions?.pull) {
                    userPermissions.permission = 'read';
                    userPermissions.canPush = false;
                    userPermissions.canPull = true;
                } else {
                    userPermissions.permission = 'none';
                    userPermissions.canPush = false;
                    userPermissions.canPull = false;
                }

                updatePermissionUI();
                
                log(`‚úì User: ${userPermissions.username}`);
                log(`‚úì Permission level: ${userPermissions.permission}`);

            } catch (error) {
                log(`‚ö†Ô∏è  Permission check failed: ${error.message}`, 'text-yellow-400');
                // Fallback to public access
                userPermissions.authenticated = false;
                userPermissions.permission = 'read';
                userPermissions.canPush = false;
                userPermissions.canPull = true;
                userPermissions.username = 'Anonymous (Public Access)';
                updatePermissionUI();
            }
        }
        
        function updatePermissionUI() {
            // ... (this function is unchanged, it's still good) ...
            const badge = document.getElementById('permissionBadge');
            const userInfo = document.getElementById('userInfo');
            const authStatus = document.getElementById('authStatus');
            const currentPerms = document.getElementById('currentPermissions');
            const loadCollabBtn = document.getElementById('loadCollabBtn');

            let badgeClass = '';
            let badgeIcon = '';
            let badgeText = '';
            let authStatusHtml = '';

            if (!userPermissions.authenticated) {
                badgeClass = 'bg-gray-500';
                badgeIcon = 'fa-globe';
                badgeText = 'Public Access';
                authStatusHtml = '<div class="text-xs text-gray-400 mt-1"><i class="fas fa-info-circle"></i> No authentication</div>';
            } else {
                switch(userPermissions.permission) {
                    case 'admin':
                        badgeClass = 'bg-green-500';
                        badgeIcon = 'fa-crown';
                        badgeText = 'Admin';
                        break;
                    case 'write':
                        badgeClass = 'bg-blue-500';
                        badgeIcon = 'fa-pen';
                        badgeText = 'Write Access';
                        break;
                    case 'read':
                        badgeClass = 'bg-yellow-500';
                        badgeIcon = 'fa-eye';
                        badgeText = 'Read Only';
                        break;
                    default:
                        badgeClass = 'bg-red-500';
                        badgeIcon = 'fa-ban';
                        badgeText = 'No Access';
                }
                authStatusHtml = '<div class="text-xs text-green-400 mt-1"><i class="fas fa-check-circle"></i> Authenticated</div>';
            }

            badge.innerHTML = `
                <div class="${badgeClass} text-white px-3 py-1 rounded-lg text-xs font-medium flex items-center gap-2">
                    <i class="fas ${badgeIcon}"></i>
                    <span>${badgeText}</span>
                </div>
            `;

            authStatus.innerHTML = authStatusHtml;

            userInfo.textContent = `User: ${userPermissions.username}`;
            userInfo.classList.remove('hidden');

            // Show detailed permissions
            if (currentPerms) {
                // ... (code unchanged) ...
            }

            // Update button states
            const saveBtn = document.getElementById('saveBtn');
            
            if (!userPermissions.canPush) {
                if (saveBtn) saveBtn.title = 'Authentication required for write access';
            }

            // Update collaborators button
            if (loadCollabBtn) {
                loadCollabBtn.disabled = !userPermissions.authenticated;
            }

            // Update editor if it exists
            if (monacoEditor) {
                monacoEditor.updateOptions({ readOnly: !userPermissions.canPush });
            }
        }
        
        function checkPermission(action) {
            // ... (this function is unchanged) ...
        }


        // ... UI Functions (switchView, showLoading, hideLoading, showToast, log, parseRepoUrl) ...
        // (These functions are unchanged)
        function switchView(viewName) {
            document.querySelectorAll('.view-container').forEach(v => v.classList.add('hidden'));
            document.querySelectorAll('.nav-item').forEach(n => {
                n.classList.remove('bg-indigo-600', 'border-indigo-500');
            });
            
            document.getElementById('view-' + viewName).classList.remove('hidden');
            if (event && event.target) {
                event.target.closest('.nav-item').classList.add('bg-indigo-600', 'border-indigo-500');
            }
        }
        function showLoading(text = 'Processing...', subtext = 'Please wait') {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingSubtext').textContent = subtext;
            document.getElementById('loadingOverlay').classList.remove('hidden');
            document.getElementById('loadingOverlay').classList.add('flex');
        }
        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
            document.getElementById('loadingOverlay').classList.remove('flex');
        }
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            // ... (code unchanged) ...
        }
        function log(message, color = 'text-green-400') {
            const output = document.getElementById('consoleOutput');
            // ... (code unchanged) ...
        }
        function parseRepoUrl(url) {
            // ... (code unchanged) ...
        }


        // NEW: Repository Sync Metadata
        async function syncMetadata() {
            const token = document.getElementById('tokenInput').value.trim();
            const repoInput = document.getElementById('repoInput').value.trim();

            if (!repoInput) {
                showToast('Please enter a repository URL', 'error');
                return;
            }

            const parsed = parseRepoUrl(repoInput);
            if (!parsed) {
                showToast('Invalid repository format', 'error');
                return;
            }

            currentRepo = {
                owner: parsed.owner,
                repo: parsed.repo,
                branch: '', // Will be set by user
                token: token
            };

            showLoading('Syncing metadata...', 'Fetching repo info & branches');
            
            try {
                // Check user permissions
                await checkUserPermissions();
                if (!checkPermission('read')) {
                    throw new Error('You do not have permission to access this repository');
                }
                
                // Get repo info
                const infoResponse = await fetch(
                    `https://api.github.com/repos/${currentRepo.owner}/${currentRepo.repo}`,
                    { headers: getHeaders() }
                );
                if (!infoResponse.ok) throw new Error('Failed to get repo info');
                const repoInfo = await infoResponse.json();
                
                // Get branches
                const branchResponse = await fetch(
                    `https://api.github.com/repos/${currentRepo.owner}/${currentRepo.repo}/branches`,
                    { headers: getHeaders() }
                );
                if (!branchResponse.ok) throw new Error('Failed to get branches');
                const branches = await branchResponse.json();

                // Populate UI
                document.getElementById('repoMetadataOutput').textContent = `
                    ${repoInfo.full_name}
                    ${repoInfo.description || ''}
                    ‚≠ê ${repoInfo.stargazers_count}  |  üç¥ ${repoInfo.forks_count}
                `;

                const branchSelect = document.getElementById('branchSelect');
                branchSelect.innerHTML = '';
                branches.forEach(branch => {
                    const option = document.createElement('option');
                    option.value = branch.name;
                    option.textContent = branch.name;
                    if (branch.name === repoInfo.default_branch) {
                        option.selected = true;
                    }
                    branchSelect.appendChild(option);
                });
                
                // Set default branch
                currentRepo.branch = repoInfo.default_branch;

                document.getElementById('repoMetadataSection').classList.remove('hidden');
                showToast('Metadata synced!', 'success');
                log('‚úì Metadata synced');

            } catch (error) {
                log(`‚úó Error: ${error.message}`, 'text-red-400');
                showToast('Sync failed: ' + error.message, 'error');
            } finally {
                hideLoading();
            }
        }
        
        // REWORKED: Clone Repository (now called from new UI)
        async function cloneRepository() {
            // SW-REFACTOR: This whole function should be a message to the SW
            // postToSW({ type: 'CLONE_REPO', payload: currentRepo });
            
            const selectedBranch = document.getElementById('branchSelect').value;
            currentRepo.branch = selectedBranch;
            
            document.getElementById('consoleOutput').textContent = '';
            
            if (hasToken()) {
                showLoading('Cloning repository...', 'Using authentication');
            } else {
                showLoading('Cloning public repository...', 'No authentication');
            }
            
            try {
                // Permissions should already be checked by syncMetadata, but we check again.
                await checkUserPermissions();
                if (!checkPermission('read')) {
                    throw new Error('You do not have permission to access this repository');
                }

                log(`üöÄ Starting clone: ${currentRepo.owner}/${currentRepo.repo}`);
                log(`üìç Branch: ${currentRepo.branch}`);
                
                document.getElementById('cloneProgress').classList.remove('hidden');
                updateProgress(10, 'Fetching repository info...');

                // Get repo info (again, to be safe, or get from cache)
                const infoResponse = await fetch(
                    `https://api.github.com/repos/${currentRepo.owner}/${currentRepo.repo}`,
                    { headers: getHeaders() }
                );
                const repoInfo = await infoResponse.json();
                await saveToIndexedDB('metadata', { key: 'repoInfo', value: repoInfo });
                
                updateProgress(20, 'Fetching file tree...');

                // Get tree
                const treeResponse = await fetch(
                    `https://api.github.com/repos/${currentRepo.owner}/${currentRepo.repo}/git/trees/${currentRepo.branch}?recursive=1`,
                    { headers: getHeaders() }
                );
                const treeData = await treeResponse.json();
                const files = treeData.tree.filter(item => item.type === 'blob');
                
                log(`‚úì Found ${files.length} files`);
                await saveToIndexedDB('metadata', { key: 'tree', value: treeData.tree });
                
                updateProgress(30, `Downloading ${files.length} files...`);

                // Download files
                let downloaded = 0;
                const batchSize = 10;
                
                for (let i = 0; i < files.length; i += batchSize) {
                    const batch = files.slice(i, Math.min(i + batchSize, files.length));
                    
                    await Promise.all(batch.map(async (file) => {
                        try {
                            const fileResponse = await fetch(
                                `https://api.github.com/repos/${currentRepo.owner}/${currentRepo.repo}/contents/${file.path}?ref=${currentRepo.branch}`,
                                { headers: getHeaders() }
                            );

                            if (fileResponse.ok) {
                                const fileData = await fileResponse.json();
                                await saveToIndexedDB('files', {
                                    path: file.path,
                                    content: fileData.content,
                                    encoding: fileData.encoding,
                                    size: fileData.size,
                                    sha: fileData.sha,
                                    isDirty: false // NEW: Track modification status
                                });
                                downloaded++;
                            }
                        } catch (error) {
                            log(`‚ö†Ô∏è  Failed: ${file.path}`, 'text-red-400');
                        }
                    }));

                    const progress = 30 + Math.floor((downloaded / files.length) * 60);
                    updateProgress(progress, `Downloaded ${downloaded}/${files.length} files`);
                }

                updateProgress(90, 'Saving metadata...');
                await saveToIndexedDB('metadata', { key: 'currentRepo', value: currentRepo });
                await saveToIndexedDB('metadata', { key: 'userPermissions', value: userPermissions });
                updateProgress(100, 'Complete!');
                
                log(`‚úì Clone completed: ${downloaded} files downloaded`);
                showToast('Repository cloned successfully!', 'success');
                
                updateRepositoryUI();
                loadFileTree(); // This will now show modification status
                
                setTimeout(() => {
                    document.getElementById('cloneProgress').classList.add('hidden');
                }, 2000);

            } catch (error) {
                log(`‚úó Error: ${error.message}`, 'text-red-400');
                showToast('Clone failed: ' + error.message, 'error');
            } finally {
                hideLoading();
            }
        }
        
        // NEW: Browse-only mode (stub)
        function browseFilesOnly() {
            showToast('Browse-only mode is not yet implemented', 'info');
            // TODO: This would fetch the tree but not download files.
            // openFile() would be modified to download on-demand.
        }

        function updateProgress(percent, text) {
            // ... (this function is unchanged) ...
        }

        async function updateRepositoryUI() {
            // ... (this function is unchanged) ...
        }

        // REWORKED: File Tree (shows modification status)
        async function loadFileTree() {
            const tree = await getFromIndexedDB('metadata', 'tree');
            if (!tree) return;
            
            // Get all dirty files to cross-reference
            const dirtyFiles = await getDirtyFiles();
            const dirtyPaths = new Set(dirtyFiles.map(f => f.path));

            const treeContainer = document.getElementById('fileTree');
            treeContainer.innerHTML = '';

            const buildTree = (items) => {
                const structure = {};
                items.forEach(item => {
                    const parts = item.path.split('/');
                    let current = structure;
                    
                    parts.forEach((part, index) => {
                        if (!current[part]) {
                            current[part] = {
                                type: index === parts.length - 1 && item.type === 'blob' ? 'file' : 'folder',
                                path: item.path,
                                children: {}
                            };
                        }
                        current = current[part].children;
                    });
                });
                return structure;
            };

            const renderTree = (obj, container, level = 0) => {
                Object.keys(obj).sort().forEach(key => {
                    const item = obj[key];
                    const div = document.createElement('div');
                    div.className = 'flex items-center gap-2 py-2 px-3 rounded-lg hover:bg-gray-100 cursor-pointer transition-colors tree-item';
                    div.style.paddingLeft = (level * 20 + 12) + 'px';
                    
                    // NEW: Add dirty indicator
                    const isDirty = item.type === 'file' && dirtyPaths.has(item.path);
                    const dirtyIndicator = isDirty ? '<span class="file-modified-indicator">M</span>' : '';
                    
                    if (item.type === 'file') {
                        div.innerHTML = `<i class="fas fa-file text-gray-400 text-xs"></i><span class="text-sm">${key}</span>${dirtyIndicator}`;
                        div.onclick = (e) => openFile(item.path, e);
                    } else {
                        div.innerHTML = `<i class="fas fa-folder text-yellow-500 text-xs"></i><span class="text-sm font-medium">${key}</span>`;
                        // ... (folder logic unchanged) ...
                        container.appendChild(div);
                        return;
                    }
                    
                    container.appendChild(div);
                });
            };

            const structure = buildTree(tree.value);
            renderTree(structure, treeContainer);
            
            // Also refresh the Source Control change list
            updateChangedFilesList();
        }
        
        // NEW: Update Source Control change list
        async function updateChangedFilesList() {
            const dirtyFiles = await getDirtyFiles();
            const container = document.getElementById('changedFilesList');
            container.innerHTML = '';

            if (dirtyFiles.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-400 py-8">No changes detected</div>';
                return;
            }
            
            dirtyFiles.forEach(file => {
                const div = document.createElement('div');
                div.className = 'bg-gray-50 rounded-lg p-3 flex items-center gap-3 cursor-pointer hover:bg-gray-100';
                div.innerHTML = `
                    <i class="fas fa-file text-gray-600"></i>
                    <span class="text-sm font-medium text-gray-800">${file.path}</span>
                    <span class="file-modified-indicator ml-auto">M</span>
                `;
                div.onclick = () => {
                    switchView('files');
                    openFile(file.path, null);
                };
                container.appendChild(div);
            });
        }


        // ... initMonacoEditor ...
        function initMonacoEditor() {
            // ... (this function is unchanged) ...
        }

        // REWORKED: openFile (tracks original content)
        async function openFile(path, e) {
            try {
                if (!monacoEditor) {
                    showLoading('Loading Editor...', 'Just a moment');
                    await initMonacoEditor(); 
                    hideLoading();
                }

                const file = await getFromIndexedDB('files', path);
                if (!file) {
                    showToast('File not found', 'error');
                    return;
                }

                const content = atob(file.content);

                // Set global state
                currentFile = {
                    path: path,
                    originalContent: content // Store original content
                };
                fileModified = false;

                const extension = path.split('.').pop();
                // ... (languageMap unchanged) ...
                const language = 'javascript'; // simplified
                
                monaco.editor.setModelLanguage(monacoEditor.getModel(), language);
                monacoEditor.setValue(content);
                monacoEditor.updateOptions({ readOnly: !checkPermission('write') });
                
                document.getElementById('editorFilename').innerHTML = `
                    <i class="fas fa-file-code"></i>
                    <span>${path}</span>
                `;

                // Highlight tree item
                document.querySelectorAll('.tree-item').forEach(item => item.classList.remove('bg-indigo-100'));
                if (e && e.target) {
                    e.target.closest('.tree-item').classList.add('bg-indigo-100');
                }
                
                // Disable save button until changes are made
                document.getElementById('saveBtn').disabled = true;

            } catch (error) {
                hideLoading();
                console.error("Failed to open file or load editor:", error);
            }
        }

        // REWORKED: saveFile (implements new "dirty" logic)
        async function saveFile() {
            if (!currentFile.path || !fileModified) return;

            if (!checkPermission('write')) {
                showToast('Authentication required for write access', 'error');
                return;
            }

            try {
                const newContent = monacoEditor.getValue();
                const encoded = btoa(newContent);
                
                const file = await getFromIndexedDB('files', currentFile.path);
                file.content = encoded;
                file.size = new Blob([newContent]).size;
                
                // NEW: Check if content is different from original SHA
                // This is a simplified check. A true "dirty" check would
                // compare against the SHA, not the last-opened content.
                // But for this flow, we check if it's different from when we loaded it.
                // A better check would be against the *base* SHA from the clone.
                // For now, any save marks it as "dirty" until pushed.
                file.isDirty = true; 
                
                await saveToIndexedDB('files', file);
                
                fileModified = false;
                document.getElementById('saveBtn').disabled = true;
                
                showToast('File saved locally', 'success');
                log(`‚úì Saved: ${currentFile.path}`);
                
                // Refresh file tree to show 'M' indicator
                loadFileTree();

            } catch (error) {
                showToast('Save failed: ' + error.message, 'error');
            }
        }

        // NEW: Commit & Push All (replaces single-file logic)
        async function commitAndPushAll() {
            if (!checkPermission('write')) {
                showToast('Authentication required to push changes', 'error');
                return;
            }

            const message = document.getElementById('commitMessage').value.trim();
            if (!message) {
                showToast('Please enter a commit message', 'error');
                return;
            }
            
            const dirtyFiles = await getDirtyFiles();
            if (dirtyFiles.length === 0) {
                showToast('No changes to commit', 'info');
                return;
            }

            showLoading('Committing changes...', 'Pushing to GitHub');
            log(`Committing ${dirtyFiles.length} files...`);

            // SW-REFACTOR: This logic should be in the Service Worker
            // postToSW({ 
            //     type: 'COMMIT_FILES', 
            //     payload: { 
            //         message: message, 
            //         files: dirtyFiles 
            //     } 
            // });

            // -----------------------------------------------------------------
            // ! COMPLEXITY WARNING !
            // -----------------------------------------------------------------
            // The code below is a placeholder. A real implementation
            // must use the Git Data API (Blobs, Trees, Commits, Refs).
            // The old Contents API (looping PUT requests) is NOT atomic
            // and will fail.
            //
            // PSEUDO-CODE for Git Data API implementation:
            //
            // 1. Get current branch ref (e.g., 'refs/heads/main')
            //    -> Geta parent commit SHA
            // 2. Get parent commit
            //    -> Get base tree SHA
            // 3. Create NEW blobs for all *changed files*
            //    -> Collect array of { path, sha, mode, type }
            // 4. Create NEW tree using base tree and new blobs
            //    -> POST /repos/.../git/trees
            //    -> Get new tree SHA
            // 5. Create NEW commit
            //    -> POST /repos/.../git/commits
            //    -> Body: { message, tree: newTreeSha, parents: [parentCommitSha] }
            //    -> Get new commit SHA
            // 6. Update branch ref to point to new commit
            //    -> PATCH /repos/.../git/refs/heads/main
            //    -> Body: { sha: newCommitSha }
            // 7. On success, update all `isDirty` and `sha` fields in IndexedDB
            
            try {
                // This is a placeholder and will not work for multiple files
                //
                // for (const file of dirtyFiles) {
                //    // ... old PUT logic ...
                // }
                //
                // We will simulate a success for UI purposes
                
                console.error("Git Data API not implemented");
                log('‚ùå ERROR: Multi-file commit logic (Git Data API) is not implemented.', 'text-red-400');
                log('This is a placeholder. See comments in commitAndPushAll()', 'text-yellow-400');

                // Simulate a delay
                await new Promise(res => setTimeout(res, 2000));
                
                // If it WERE successful, we would do this:
                for (const file of dirtyFiles) {
                    file.isDirty = false;
                    // file.sha = newShaFromApi; // Update SHA
                    await saveToIndexedDB('files', file);
                }
                
                showToast('Commit & Push (Simulation) Complete!', 'success');
                document.getElementById('commitMessage').value = '';
                loadFileTree(); // Reloads tree (removes 'M') and source control list
                
            } catch (error) {
                showToast('Push failed: 'ind + error.message, 'error');
                log(`‚úó Push failed: ${error.message}`, 'text-red-400');
            } finally {
                hideLoading();
            }
        }
        
        // NEW: Create New Branch
        async function createNewBranch() {
            if (!checkPermission('write')) {
                showToast('Authentication required to create branches', 'error');
                return;
            }
            
            const newBranch = document.getElementById('newBranchName').value.trim();
            let sourceBranch = document.getElementById('newBranchSource').value.trim();

            if (!newBranch) {
                showToast('Please enter a new branch name', 'error');
                return;
            }

            showLoading('Creating branch...', `Branch: ${newBranch}`);

            try {
                // 1. Get source branch SHA
                if (!sourceBranch) {
                    sourceBranch = currentRepo.branch || 'main';
                }
                
                const refResponse = await fetch(
                    `https://api.github.com/repos/${currentRepo.owner}/${currentRepo.repo}/git/refs/heads/${sourceBranch}`,
                    { headers: getHeaders() }
                );
                if (!refResponse.ok) throw new Error(`Could not find source branch '${sourceBranch}'`);
                const refData = await refResponse.json();
                const sourceSha = refData.object.sha;
                
                // 2. Create new branch (ref)
                const createResponse = await fetch(
                    `https://api.github.com/repos/${currentRepo.owner}/${currentRepo.repo}/git/refs`,
                    {
                        method: 'POST',
                        headers: getHeaders(),
                        body: JSON.stringify({
                            ref: `refs/heads/${newBranch}`,
                            sha: sourceSha
                        })
                    }
                );
                
                if (!createResponse.ok) {
                    const error = await createResponse.json();
                    throw new Error(error.message || 'Failed to create branch');
                }
                
                showToast(`Branch '${newBranch}' created!`, 'success');
                log(`‚úì Branch created: ${newBranch}`);
                loadBranches(); // Refresh branch list

            } catch (error) {
                showToast('Failed to create branch: ' + error.message, 'error');
                log(`‚úó Branch creation failed: ${error.message}`, 'text-red-400');
            } finally {
                hideLoading();
            }
        }


        // ... searchCode, addSearchResult, loadCommits, loadBranches, loadCollaborators, downloadAsZip ...
        // (These functions are unchanged and still work)
        async function searchCode() { /* ... */ }
        function addSearchResult(filepath, content, lineInfo) { /* ... */ }
        async function loadCommits() { /* ... */ }
        async function loadBranches() { /* ... */ }
        async function loadCollaborators() { /* ... */ }
        async function downloadAsZip() { /* ... */ }


        // ... saveSettings, showStorageInfo, clearAllData, loadRepoInfo ...
        // (These functions are unchanged and still work)
        async function saveSettings() { /* ... */ }
        async function showStorageInfo() { /* ... */ }
        async function clearAllData() { /* ... */ }
        async function loadRepoInfo() { /* ... */ }
        

        // Initialize
        window.addEventListener('load', async () => {
            try {
                // registerServiceWorker(); // Register the SW
                await initDB();
                
                // Load saved repo
                const savedRepo = await getFromIndexedDB('metadata', 'currentRepo');
                if (savedRepo) {
                    currentRepo = savedRepo.value;
                    document.getElementById('tokenInput').value = currentRepo.token || '';
                    document.getElementById('repoInput').value = `${currentRepo.owner}/${currentRepo.repo}`;
                    document.getElementById('branchSelect').innerHTML = `<option>${currentRepo.branch}</option>`;
                    
                    const savedPerms = await getFromIndexedDB('metadata', 'userPermissions');
                    if (savedPerms) {
                        userPermissions = savedPerms.value;
                        updatePermissionUI();
                    }
                    
                    await updateRepositoryUI();
                    await loadFileTree(); // This will now show dirty files
                    
                    log('‚úì Loaded cached repository');
                }

                // ... (load settings unchanged) ...

                showStorageInfo();
                
                log('üöÄ GitHub Pro Client Ready!');
                
                initMonacoEditor().catch(error => {
                    console.error('Monaco editor failed to load', error);
                });
                
            } catch (error) {
                console.error('Initialization error:', error);
            }
        });
    </script>
</body>
</html>